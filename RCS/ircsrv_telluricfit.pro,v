head	1.7;
access;
symbols;
locks
	stgilhool:1.7; strict;
comment	@# @;


1.7
date	2015.03.12.03.39.57;	author stgilhool;	state Exp;
branches;
next	1.6;

1.6
date	2015.03.10.13.39.19;	author stgilhool;	state Exp;
branches;
next	1.5;

1.5
date	2015.03.03.21.26.29;	author stgilhool;	state Exp;
branches;
next	1.4;

1.4
date	2015.03.03.20.22.09;	author stgilhool;	state Exp;
branches;
next	1.3;

1.3
date	2015.03.03.18.48.36;	author stgilhool;	state Exp;
branches;
next	1.2;

1.2
date	2015.03.03.15.11.17;	author stgilhool;	state Exp;
branches;
next	1.1;

1.1
date	2015.03.02.15.01.36;	author stgilhool;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Working version with better stellar template.  Took out addition of noise to telluric template as well.
@
text
@function telluricfit, p, fakekey=fakekey

common funcargs, n_exp, $
  npix_model, $
  npix_select, $
  npix_over, $
  first_pix, $
  oversamp, $
  obs_select, $
  err_select, $
  wl_grid_over, $
  temp_wl_over, $
  template_over, $
  delta_rv, $
  nh3_spectrum, $
  h2o_over, $
  co2ch4_over, $
  wl_soln_tell, $
  wl_soln_tell_select, $
  select_tell_index, $
  lsf_arr, $
  norm_factor, $
  mode, $
  guess, $
  pscale, $
  last_guess, $
  chi2_nopen, $
  model_final

clock=tic()

last_guess=p
bigc=299792458.D

model_over=dblarr(npix_model, n_exp)
;tell_penalty=dblarr(n_elements(select_tell_index), n_exp)
tell_penalty_h2o=dblarr(n_elements(select_tell_index), n_exp)
tell_penalty_co2ch4=dblarr(n_elements(select_tell_index), n_exp)
;stellar=dblarr(npix_over, n_exp)
;telluric_model=dblarr(n_elements(

;modify telluric with free parameters
h2o_over[select_tell_index]=p[0:n_elements(wl_soln_tell_select)-1]
co2ch4_over[select_tell_index]=p[n_elements(wl_soln_tell_select):2*n_elements(wl_soln_tell_select)-1]
h2o_depth=p[2*n_elements(wl_soln_tell_select):2*n_elements(wl_soln_tell_select)+n_exp-1]
co2ch4_depth=p[2*n_elements(wl_soln_tell_select)+n_exp:2*n_elements(wl_soln_tell_select)+2*n_exp-1]
;delta_rv=p[2*n_elements(wl_soln_tell_select)+2*n_exp:2*n_elements(wl_soln_tell_select)+3*n_exp-1]





; help, p
; help, h2o_over
; help, co2ch4_over
; help, h2o_depth
; help, co2ch4_depth
; stop

;Loop through exposures for multiply and convolve
for exp=0, n_exp-1 do begin
    
    
    ;Shift stellar wl
    wl_template_shifted=temp_wl_over*(1d0 + delta_rv[exp]/bigc)
    stellar=interpol(template_over, wl_template_shifted, wl_grid_over[*, exp])
    
    ;scale optical depth of telluric
    h2o_scaled=h2o_over^h2o_depth[exp]
    co2ch4_scaled=co2ch4_over^co2ch4_depth[exp]
    
    ;save telluric "template" for roughness penalty
    ;tell_penalty[*,exp]=h2o_scaled[select_tell_index]*co2ch4_scaled[select_tell_index]
    tell_penalty_h2o[*,exp]=h2o_scaled[select_tell_index]
    tell_penalty_co2ch4[*,exp]=co2ch4_scaled[select_tell_index]
    
    ;put telluric onto wavelength grid
    h2o=interpol(h2o_scaled, wl_soln_tell, wl_grid_over[*,exp])
    co2ch4=interpol(co2ch4_scaled, wl_soln_tell, wl_grid_over[*,exp])
    
    ;telluric_model[*,exp]=interpol(h2o*co2ch4, wl_grid_over[*,exp], wl_grid_select[*,exp])
    
    
    ;Product of stell, tell and nh3
    product_spectrum=stellar*nh3_spectrum[*,exp]*h2o*co2ch4
    
    model_over[*,exp]= ircs_convolve(product_spectrum, lsf_arr[*,*,exp], oversamp=oversamp, first_pix=first_pix, npix_select=npix_select)
    
endfor


;Downsample to IRCS resolution
model = ircsrv_downsample(model_over, oversamp)


;final IRCS sampled 2d array of models
;for all exposures (n_exp x npix_select)
model_final=model*norm_factor
model_longvec=reform(transpose(model_final), n_elements(model_final))
obs_longvec=reform(transpose(obs_select), n_elements(obs_select))
;    stop    


;Add roughness penalty
roughpenalty=1
if roughpenalty ge 1 then begin
    ;Take first derivative of p
    xv=wl_soln_tell_select
    ;yv=tell_penalty[*,0]
    yv_h2o=tell_penalty_h2o[*,0]
    yv_co2ch4=tell_penalty_co2ch4[*,0]
    dx=xv[1:*]-xv[0:-2]
    ;dy=yv[1:*]-yv[0:-2]
    dy_h2o=yv_h2o[1:*]-yv_h2o[0:-2]
    dy_co2ch4=yv_co2ch4[1:*]-yv_co2ch4[0:-2]
    ;der=dy/dx
    der_h2o=dy_h2o/dx
    der_co2ch4=dy_co2ch4/dx
    
    ;pscale=1d-5
    
    ;rpenalty=pscale*total(der[10*oversamp:*]^2, /double) ;FIX
    ;careful with this
    rpenalty_h2o=pscale*total(der_h2o[10*oversamp:*]^2, /double) ;FIX careful with this
    rpenalty_co2ch4=pscale*total(der_co2ch4[10*oversamp:*]^2, /double) ;FIX careful with this
    rpenalty=rpenalty_h2o+rpenalty_co2ch4
    penstopon=0
    if penstopon eq 0 then penstop=[0] else penstop=randomu(seed,1)
    if penstop[0] gt .999 then stop
endif

;Calculate chi2
if mode eq 'amoeba' then begin
    chi2_allexp=((model_final-obs_select)/err_select)^2
    chi2_arr=total(chi2_allexp, 2, /double)
    chi2=total(chi2_arr, /double)
    chi2_nopen=chi2
    if roughpenalty ge 1 then chi2=chi2+rpenalty
    print, chi2_nopen, chi2
endif
if mode eq 'mpfit' or mode eq 'one_call' then begin
    chi_allexp=(obs_select-model_final)/err_select
    ;chi_arr=reform(transpose(chi_allexp), n_elements(chi_allexp))
    chi_arr=reform(chi_allexp, n_elements(chi_allexp))
    ;chi_arr=total(chi_allexp, 2, /double)
    chi2_nopen=total((chi_arr)^2, /double)
    if roughpenalty eq 1 then begin ; this is kinda wrong, but okay
        pen=rpenalty/n_elements(chi_arr)
        pen=sqrt(pen)
        poschi=where(chi_arr ge 0, poscount)
        negchi=where(chi_arr lt 0, negcount)
        if poscount gt 0 then chi_arr[poschi]=chi_arr[poschi]+pen
        if negcount gt 0 then chi_arr[negchi]=chi_arr[negchi]-pen
        chi2_tot=total(chi_arr^2, /double)
    endif else if roughpenalty eq 2 then begin
        
        negchi=where(chi_arr lt 0, negcount)
        chi2_tot=chi2_nopen+rpenalty
        chi2perpix=chi2_tot/n_elements(chi_arr)
        chiperpix=sqrt(chi2perpix)
        chi_arr=replicate(chiperpix, n_elements(chi_arr))
        if negcount gt 0 then chi_arr[negchi]=-1d0 * chi_arr[negchi]
;            if finite(chi2_nopen) eq 0 then stop
        
    endif
    
    print, chi2_nopen, total(chi_arr^2, /double)
    ;help, chi_arr
    ;help, p
    ;stop
endif

; help, chi2_tot
; help, chi_arr
; stop    

res_longvec=reform(transpose((obs_select-model_final)), n_elements(obs_select))
;i=1
;plot, obs_select[*,i], /xs, yr=[0,1.3]
;oplot, model_final[*,i], ps=3, color=200
;plot, obs_select[*,i]-model_final[*,i], ps=3, /xs
;plot, obs_longvec, /xs, yr=[0,1.3]
;oplot, model_longvec, ps=6, color=200
;plot, res_longvec, /xs, ps=6
;oplot, p, ps=3, color=200
;wait, 0.01
;    stop
randomon=0
if randomon eq 1 then begin 
    
    randomplot=randomu(seed, 1) 
endif else randomplot=[0]
if randomplot[0] gt 0.99 then begin
    
    !p.multi=[0,3,n_exp]
    for i=0, n_exp-1 do begin
        plot, obs_select[*,i], /xs, yr=[0,1.3]
        oplot, model_final[*,i], ps=3, color=200
        plot, obs_select[*,i]-model_final[*,i], ps=3, /xs, yr=[-0.1,0.1]
        plot, tell_penalty_h2o[*,i], /xs, yr=[0,1.3]
        oplot, tell_penalty_co2ch4[*,i], color=200
    endfor
endif


;randomstop=randomu(seed, 1)
randomstop=[0]
if randomstop[0] gt 0.9 then begin
    for i=0, n_exp-1 do begin
        plot, obs_select[*,i], /xs, yr=[0,1.3]
        oplot, model_final[*,i], ps=3, color=200
        plot, obs_select[*,i]-model_final[*,i], ps=3, /xs
        print, "Obs: ", i, " Chi2: ", total((chi_allexp[*,i]^2), /double)
        stop
    endfor
endif


if mode eq 'amoeba' then return, chi2 
if mode eq 'mpfit' then return, chi_arr
if mode eq 'one_call' then begin
    ocstr={model_final:model_final, chi2_nopen:chi2_nopen, chi2_tot:chi2_tot}
;        stop
    return, ocstr
endif


end



pro ircsrv_telluricfit, epoch=epoch, object=object, trace=trace, visualize=visualize, first_pix=first_pix, npix_select=npix_select, mode=mode


common funcargs, n_exp, $
  npix_model, $
  npixselect, $
  npix_over, $
  firstpix, $
  oversamp, $
  obs_select, $
  err_select, $
  wl_grid_over, $
  temp_wl_over, $
  template_over, $
  delta_rv, $
  nh3_spectrum, $
  h2o_over, $
  co2ch4_over, $
  wl_soln_tell, $
  wl_soln_tell_select, $
  select_tell_index, $
  lsf_arr, $
  norm_factor, $
  fmode, $
  guess, $
  pscale, $
  last_guess, $
  chi2_nopen, $
  model_final


npix=1024L
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;MAIN BODY ;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
if n_elements(epoch) eq 0 then epoch='18Jan2011'
if n_elements(object) eq 0 then object='GJ273'
if n_elements(trace) eq 0 then trace='AB'


if n_elements(visualize) eq 0 then visualize=1
;Define keywords for fitting just a range
if n_elements(first_pix) eq 0 then first_pix=0
if n_elements(npix_select) eq 0 then npix_select=128L ;npix_select=npix-first_pix
if n_elements(mode) eq 0 then mode='mpfit'



;set file paths
rootpath='/home/stgilhool/RV_projects/IRCS_rv/data/'
epochpath=rootpath+'epoch/'+epoch+'/'
objectpath=epochpath+'final_spectra/'
flatpath=epochpath+'final_spectra/'
calibpath=epochpath+'calib_results/'
outpath=epochpath+'temp_results/'
modelpath=rootpath+'supplemental/'
outputpath=epochpath+'rv_results/'
rvshift1outpath=rootpath+'rvshift1_results/'
templatepath=rootpath+object+'/'

;p=paths(epoch=epoch, object=object, trace=trace)
;rootpath=p.dataroot
;epochpath=p.epochfold
;objectpath=p.specfold
;flatpath=p.specfold
;outpath=p.tempfold
;modelpath=p.dataroot+'supplemental/'


;Define flat file names and full path file names
ABflat_filename=strjoin(['NH3', object, epoch, 'AB1'], '_')+'.fits'
BAflat_filename=strjoin(['NH3', object, epoch, 'BA1'], '_')+'.fits'
ABflat_file=flatpath+strjoin(['NH3', object, epoch, 'AB1'], '_')+'.fits'
BAflat_file=flatpath+strjoin(['NH3', object, epoch, 'BA1'], '_')+'.fits'


;Define object file names and full path file names
ABobj_listname=strjoin([object, epoch, 'AB'], '_')+'.list'
BAobj_listname=strjoin([object, epoch, 'BA'], '_')+'.list'
ABobj_list=objectpath+strjoin([object, epoch, 'AB'], '_')+'.list'
BAobj_list=objectpath+strjoin([object, epoch, 'BA'], '_')+'.list'


;Read in object filenames and then spectra
readcol, ABobj_list, ABobj_filename, format='A'
readcol, BAobj_list, BAobj_filename, format='A'

ABobj_file=objectpath+ABobj_filename
BAobj_file=objectpath+BAobj_filename

n_ABobj=n_elements(ABobj_file)
n_BAobj=n_elements(BAobj_file)


;Initialize arrays of spectra
temp_str=mrdfits(ABobj_file[0], 1)
temp_spectrum=temp_str.spectrum
npix=n_elements(temp_spectrum)
ABspec_arr=dblarr(n_ABobj, npix)
BAspec_arr=dblarr(n_BAobj, npix)
ABflat_arr=dblarr(n_ABobj, npix)
BAflat_arr=dblarr(n_BAobj, npix)

ABmjd_arr=dblarr(n_ABobj)
BAmjd_arr=dblarr(n_BAobj)

ABerr_arr=dblarr(n_ABobj, npix)
BAerr_arr=dblarr(n_BAobj, npix)

;Set continuum normalization params
low_reject=0.53
high_reject=3.0

;Loop through each object file and flip and normalize it
for f=0, n_ABobj-1 do begin
    ABobj_spec=mrdfits(ABobj_file[f], 1)
    BAobj_spec=mrdfits(BAobj_file[f], 1)
    
    ABspec_backwards=ABobj_spec.spectrum
    BAspec_backwards=BAobj_spec.spectrum

    ;Flip the spectra
    ABspec=reverse(ABspec_backwards)
    BAspec=reverse(BAspec_backwards)

    ;Read in and flip errors
    ABerr=reverse(ABobj_spec.sigma)
    BAerr=reverse(BAobj_spec.sigma)

    ;Get MJD
    ABhead=ABobj_spec.header
    BAhead=BAobj_spec.header
    
    ;Normalize the model spectrum and the observed spectrum
    ABnorm=continuum_fit(dindgen(npix), ABspec, low_rej=low_reject, high_rej=high_reject)
    BAnorm=continuum_fit(dindgen(npix), BAspec, low_rej=low_reject, high_rej=high_reject)
    ;Populate arrays
    ;spectra
    ABspec_arr[f,*]=ABspec/ABnorm
    BAspec_arr[f,*]=BAspec/BAnorm
    ;errors
    ABerr_arr[f,*]=ABerr/ABnorm
    BAerr_arr[f,*]=BAerr/BAnorm
    ;MJD
    ABmjd_arr[f]=sxpar(ABhead, 'MJD')
    BAmjd_arr[f]=sxpar(BAhead, 'MJD')

endfor

;;;;;;;

;READ IN CALIBRATION RESULTS
calib_file='GJ273_18Jan2011_AB1_5_7_7_13.fits'
calib_ext=13
;model_file=calibpath+calib_file
model_file=rootpath+'epoch/18Jan2011/calib_results/'+calib_file
model_par=mrdfits(model_file, calib_ext)

;RENAME SOME COMMON BLOCK VARIABLES
npixels=1024L
visual=visualize
npixselect=npix_select
firstpix=first_pix
fmode=mode

;ASSUME LIN_SWITCH IS ON
lin_switch=1

;PARAMETERS FROM EARLIER CALIBRATION
;wl
wl_coeff=model_par.wl_result
wl_scale=model_par.wl_scale


;OTHER PARAMETERS AND CONSTANTS
oversamp_old=model_par.oversamp
oversamp=3L
npix_lsf=(oversamp*10L)+1L
bigc=299792458.D
npix_model=npix_select*oversamp
npix_over=npix*oversamp
npix_model_old=npix_select*oversamp_old
npix_over_old=npix*oversamp_old


;READ IN LAB SPECTRUM
modelfile= modelpath+'NH3_model.dat'
readcol, modelfile, wl_lab, int_lab, format='D,D'

norm_lab=continuum_fit(wl_lab, int_lab, low_rej=low_reject, high_rej=high_reject)
int_lab_copy=int_lab
int_lab=int_lab_copy/norm_lab



;CONTSTRUCT WL ARRAY AND OVERSAMPLED WL ARRAY FROM COEFFS
x=dindgen(npix)
xx=(dindgen(npix*oversamp)-(oversamp/2))/oversamp

wl_soln=poly(x, wl_coeff)
wl_soln_over=poly(xx, wl_coeff)

                                ;;REDEFINE THOSE VECTORS TO REFLECT ONLY THE SPECIFIED RANGE
x_select=dindgen(npix_select)+first_pix
xx_select=(dindgen(npix_model)-(oversamp/2))/oversamp+first_pix

wl_soln_select=poly(x_select, wl_coeff)
wl_soln_over_select=poly(xx_select, wl_coeff)
;



;READ IN TEMPLATE

templatefile='/home/stgilhool/RV_projects/IRCS_rv/data/smooth_penalty_test/test17/penaltytest.fits'
temp_ext=1
templatestr=mrdfits(templatefile, temp_ext)
temp_spec=templatestr.template_spec
temp_wl=templatestr.template_wl

if oversamp ne 7 then begin
    temp_oversamp=7L
    xx_temp=(dindgen(npix*temp_oversamp)-(temp_oversamp/2))/temp_oversamp
    temp_wl_over=interpol(temp_wl, xx_temp, xx)
    template_over=interpol(temp_spec, temp_wl, temp_wl_over)
    
endif else begin
    template_over=temp_spec
    temp_wl_over=temp_wl
endelse

template_over_select=template_over[first_pix*oversamp:(first_pix+npix_select)*oversamp-1]
;


;READ IN TELLURIC

h2ostr=mrdfits(modelpath+'sky_h2o.fits',1)
co2ch4str=mrdfits(modelpath+'sky_co2andch4.fits', 1)

wl_telluric_long=h2ostr.wave
h2o_long=h2ostr.trans
co2ch4_long=co2ch4str.trans

m24index=where(wl_telluric_long gt 2.275 and wl_telluric_long lt 3.365)
wl_telluric=wl_telluric_long[m24index]
h2o=h2o_long[m24index]
co2ch4=co2ch4_long[m24index]
;


                                ;;DEFINE SOME ARRAYS

varray=[0,1,2,3,4,6,10,11,12,13]
;if visit eq 5 or visit eq 7 then continue
;varray=[0,1,2,3,4,6,8,9,10,11,12,13]
;varray=[0,1,2,3]

n_exp=n_elements(varray)
lsf=dblarr(npix_lsf, npix_model, n_exp)
nh3_spectrum=dblarr(npix_over, n_exp)
;h2o_spectrum=dblarr(npix_over, n_exp)
;co2ch4_spectrum=dblarr(npix_over, n_exp)

wl_grid_over=dblarr(npix_over, n_exp)
err=dblarr(npix, n_exp)
final_spectrum=dblarr(npix_model)
delta_rv=dblarr(n_exp)
wl_grid_over=dblarr(npix_over, n_exp)
wl_grid_down=dblarr(npix, n_exp)
wl_template_shifted=dblarr(npix_over, n_exp)
norm_factor=dblarr(npix_select, n_exp)
obs=dblarr(npix, n_exp)
h2o_depth=dblarr(n_exp)
co2ch4_depth=dblarr(n_exp)
                                ;;



                                ;;NOW FIT EACH OBSERVATION

foreach visit, varray, index do begin
    
    
    obs[*, index]=ABspec_arr[visit, *] ;;MAKE OBSERVATION ARRAY
    
    err[*, index]=ABerr_arr[visit, *] ;;GET ERROR FOR THIS OBSERVATION
    ;MASK ENTRIES
    ;CUT OFF PIXELS ON EITHER END OF FULL 1024 PIXEL SPECTRUM
    npix_trim_start=10L
    npix_trim_end=10L
    bigerr=1d10                 ;;ERROR VALUE FOR MASKED PIXELS
    if n_elements(err[*,index]) eq 1024L then begin
        err[0:npix_trim_start-1, index]=bigerr
        err[-1L*npix_trim_end:-1, index]=bigerr
    endif
    
    
    
    ;READ IN PARAMETERS FROM 2-BASIS 2-RUN FITS
    
    ;rfile='/home/stgilhool/RV_projects/IRCS_rv/data/rvshift1_results/GJ273_18Jan2011_AB_0_127_run2sign.fits'
    rfile='/home/stgilhool/RV_projects/IRCS_rv/data/rvshift1_results/GJ273_18Jan2011_AB_0_127_t7newpen_r2free.fits'
    
    f=mrdfits(rfile, visit+1)
    re=f.result
    
    delta_rv[index]=re[f.delta_rv_index]
    delta_wl_coeff=re[f.delta_wl_index]
    h2o_depth[index]=re[f.h2o_depth_index]
    co2ch4_depth[index]=re[f.co2ch4_depth_index]
    delta_wl_coeff=re[f.delta_wl_index]
    gh0_coeff=re[f.gh0_coeff_index]
    gh1_coeff=re[f.gh1_coeff_index]
    other=re[f.other_index]
    
    tau_scale=other[0]	
    
    
    ;BEGIN MODELING
    
    ;PERTURB WL SOLN
    delta_wl=poly(xx, delta_wl_coeff)
    wl_grid_over[*, index]=wl_soln_over+delta_wl
    
    delta_wl_down=poly(x, delta_wl_coeff)
    wl_grid_down[*, index]=wl_soln+delta_wl_down
    
    
    ;NH3 LAB SPECTRUM: INTERPOLATE ONTO THE OVERSAMPLED TRIAL GRID
    ;ADJUST OPTICAL DEPTH FIRST
    int_lab_depth=int_lab^tau_scale
    nh3_spectrum[*,index]=interpol(int_lab_depth, wl_lab, wl_grid_over[*, index])
    
    ;MAKE LSF
    
    lsf[*,*,index] = ircsrv_lsf(gh0_coeff, gh1_vec=gh1_coeff, oversamp=oversamp, first_pix=first_pix, npix_select=npix_select, neg_penalty=penalty)
    
    
    ;CORRECT SMALL NORMALIZATION ERRORS BY MULTIPLYING SMOOTH FUNCTION
    if n_elements(other) gt 1 then begin
        nparam_other=n_elements(other)
        nparam_norm=nparam_other-1
        norm_pts_y=other[1:nparam_norm]
        
        ;X VECTOR OF SAME DIMENSIONS AS IRCS-RESOLUTION SPECTRUM
        norm_pts_xx=lindgen(npix_select)+first_pix
        
        ;CREATE AND POPULATE VECTOR WITH X-COORD OF NODE PTS
        norm_pts_x=dblarr(nparam_norm)
        
        norm_pts_x[0]=first_pix
        norm_pts_x[nparam_norm-1]=first_pix+npix_select-1
        x_increment=npix_select/(nparam_norm-2)
        for i=1, nparam_norm-2 do norm_pts_x[i]=norm_pts_x[i-1]+x_increment
        
        ;INTERPOLATE BETWEEN NODES WITH A SPLINE
        norm_factor[*,index]=interpol(norm_pts_y, norm_pts_x, norm_pts_xx, /spline)    
        
    endif
    
endforeach

;TRUNCATE OBSERVATIONS AND ERRORS TO MODEL LENGTH
;INDICES THAT WE ARE USING
select_index = lindgen(npix_select) + first_pix
select_index_over = lindgen(npix_select*oversamp) + first_pix*oversamp


temp_display=template_over[select_index_over] ;;STELLAR TEMPLATE

obs_select=rebin(obs[select_index, *], npix_select, n_exp)
err_select=rebin(err[select_index, *], npix_select, n_exp)

lsf_arr=temporary(lsf)



!p.multi=[0,1,2]
extra_pix=4L
xx_tell=(dindgen((npix+extra_pix)*oversamp)-(oversamp/2))/oversamp-(extra_pix/2)
xx_tell_select=(dindgen((npix_select+extra_pix)*oversamp)-(oversamp/2))/oversamp-(extra_pix/2 + first_pix)

select_tell_xx=lindgen(n_elements(xx_tell))
select_tell_index=select_tell_xx[first_pix*oversamp:(first_pix*oversamp)+(npix_select+extra_pix)*oversamp - 1]

wl_soln_tell=poly(xx_tell, wl_coeff)
wl_soln_tell_select=poly(xx_tell_select, wl_coeff)

h2o_over=interpol(h2o, wl_telluric, wl_soln_tell)
co2ch4_over=interpol(co2ch4, wl_telluric, wl_soln_tell)

h2o_guess=interpol(h2o, wl_telluric, wl_soln_tell_select)
co2ch4_guess=interpol(co2ch4, wl_telluric, wl_soln_tell_select)


;Testing of telluric stuff
telltest=0
if telltest eq 1 then begin
    help, select_index
    print, minmax(select_index)
    help, select_index_over
    print, minmax(select_index_over)
    help, x_select
    print, minmax(x_select)
    help, xx_select
    print, minmax(xx_select)
    help, xx_tell
    print, minmax(xx_tell)
    help, xx_tell_select
    print, minmax(xx_tell_select)
    help, select_tell_xx
    print, minmax(select_tell_xx)
    help, select_tell_index
    print, minmax(select_tell_index)
    help, wl_soln_tell
    print, minmax(wl_soln_tell)
    help, wl_soln_tell_select
    print, minmax(wl_soln_tell_select)
    help, h2o
    print, minmax(h2o)
    help, h2o_over
    print, minmax(h2o_over)
    help, h2o_guess
    print, minmax(h2o_guess)
        
    stop
endif


guess_orig=[h2o_guess, co2ch4_guess, h2o_depth, co2ch4_depth] ; , delta_rv] ;backup
;Shift guess values a bit so that mpfit works
guess=guess_orig
;;;Just turned this off (no noise... will mpfit still work?  if so,
;;;probably better not to add noise)
;guess[0:n_elements(wl_soln_tell_select)*2-1]=(1d0+randomn(seed, n_elements(guess_orig)-2*n_exp)*0.001d0)*guess_orig[0:n_elements(wl_soln_tell_select)*2 -1]
;toohigh=where(guess gt 1, highcount)
;if highcount gt 0 then guess[toohigh]=1d0



; help, wl_soln_tell
; help, wl_soln_tell_select
; help, guess_orig
; help, guess
; help, h2o_guess
; help, co2ch4_guess
; help, h2o_depth
; help, co2ch4_depth
; stop

maxiter=3L
for scaleiter=0, maxiter do begin
    
    ;scalelist=[5d-5, 2.5d-5, 1d-5, 7.5d-6, 5d-6]  
    ;pscale=scalelist[scaleiter]
    ;pscale=(scaleiter+1)*1d-5
    ;pscale=(scaleiter)*1d-4+(1d-3 - 1d-4/(maxiter/2.)) 
    ;pscale=1d-1^(scaleiter+1)
    pscale=1d-1^(scaleiter+2)
    ;pscale=0d0
    if fmode eq 'mpfit' then begin
        
        parinfo = replicate({fixed:0, limited:[1,1], $
                             limits:[0.0D,1D0]}, n_elements(guess))
        
        parinfo[0:10*oversamp].fixed=1
        parinfo[n_elements(wl_soln_tell_select):n_elements(wl_soln_tell_select)+(10*oversamp)].fixed=1
        
        
        r=mpfit('telluricfit',guess, bestnorm=chi2, ftol=ftol, $
                parinfo=parinfo, status=status, nfev=ncalls, niter=niter, /quiet)
        print, "Status: ", status
        
        
        h2o_final=h2o_over
        h2o_final[select_tell_index]=r[0:n_elements(wl_soln_tell_select)-1]
        
        co2ch4_final=co2ch4_over
        co2ch4_final[select_tell_index]=r[n_elements(wl_soln_tell_select):2*n_elements(wl_soln_tell_select)-1]
        
        h2o_depth_final=r[2*n_elements(wl_soln_tell_select):2*n_elements(wl_soln_tell_select)+n_exp-1]
        co2ch4_depth_final=r[2*n_elements(wl_soln_tell_select)+n_exp:2*n_elements(wl_soln_tell_select)+2*n_exp-1]
        ;delta_rv_final=r[2*n_elements(wl_soln_tell_select)+2*n_exp:2*n_elements(wl_soln_tell_select)+3*n_exp-1]
        
        fmode='one_call'
        oc=telluricfit(r)
        
        model_final=oc.model_final
        chi2_nopen=oc.chi2_nopen
        chi2_tot=oc.chi2_tot
        catch, error_status
        if error_status ne 0 then begin
            chi2_plain=-777
            goto, just_run
        endif

        chi2_plain=total(((model_final-obs_select)/err_select)^2, /double)
        just_run: catch, /cancel
        
        fmode='mpfit'
    endif
    
    if fmode eq 'amoeba' then begin
        window, 1, xsize=1200, ysize=650
        scale=replicate(1d-2, n_elements(template_over_select))
        
        r=amoeba3(ftol, scale=scale, p0=guess,function_name='telluricfit', $
                  function_value=fval, ncalls=ncalls, nmax=150000L)
        niter=ncalls
        status=-888
        if n_elements(r) eq 1 then begin
            r=last_guess
            status=-999
        endif
        chi2=fval[0]
        
        h2o_final=h2o_over
        h2o_final[select_tell_index]=r[0:n_elements(wl_soln_tell_select)-1]
        
        co2ch4_final=co2ch4_over
        co2ch4_final[select_tell_index]=r[n_elements(wl_soln_tell_select):2*n_elements(wl_soln_tell_select)-1]
        
        h2o_depth_final=r[2*n_elements(wl_soln_tell_select):2*n_elements(wl_soln_tell_select)+n_exp-1]
        co2ch4_depth_final=r[2*n_elements(wl_soln_tell_select)+n_exp:2*n_elements(wl_soln_tell_select)+2*n_exp-1]
        ;delta_rv_final=r[2*n_elements(wl_soln_tell_select)+2*n_exp:2*n_elements(wl_soln_tell_select)+3*n_exp-1]
        
        fmode='one_call'
        oc=telluricfit(r)
        chi2_tot=oc.chi2_tot
        fmode='amoeba'
    endif
    
    
    penstr={h2o:h2o_final, $
            co2ch4:co2ch4_final, $
            delta_rv_guess:delta_rv, $
            delta_rv_final:delta_rv, $
            h2o_depth_guess:h2o_depth, $
            h2o_depth_final:h2o_depth_final, $
            co2ch4_depth_guess:co2ch4_depth, $
            co2ch4_depth_final:co2ch4_depth_final, $
            wl_telluric:wl_soln_tell, $
            wl_telluric_select:wl_soln_tell_select, $
            wl_grid:wl_grid_over, $
            guess:guess, $
            chi2:chi2, $
            chi2_tot:chi2_tot, $
            chi2_nopen:chi2_nopen,$
            chi2_plain:chi2_plain, $
            pscale:pscale, $
            status:status, $
            first_pix:first_pix, $
            npix_select:npix_select, $
            model_arr:model_final, $
            obs_arr:obs_select, $
            err_arr:err_select, $
            ncalls:ncalls, $
            niter:niter $
           }
    
    ;if scaleiter eq 0 then stop
    
    outfil='/home/stgilhool/RV_projects/IRCS_rv/data/telluric_test/test7/tellurictest.fits'
    
    mwrfits, penstr, outfil
    
    
    
endfor

compare_template=1

if compare_template eq 1 then begin
;Do one final call with the original template
    fmode='one_call'
    oc=telluricfit(guess_orig)
    model_final=oc.model_final
    chi2_tot=oc.chi2_tot
    chi2_nopen=oc.chi2_nopen
    chi2=chi2_tot
    status=-111
    ncalls=1
    niter=1
    
    catch, error_status2
    if error_status2 ne 0 then begin
        chi2_plain=-777
        goto, just_run2
    endif
    
    chi2_plain=total(((model_final-obs_select)/err_select)^2, /double)
    just_run2: catch, /cancel
    
    
    
    penstr={h2o:h2o_final, $
            co2ch4:co2ch4_final, $
            delta_rv_guess:delta_rv, $
            delta_rv_final:delta_rv, $
            h2o_depth_guess:h2o_depth, $
            h2o_depth_final:h2o_depth_final, $
            co2ch4_depth_guess:co2ch4_depth, $
            co2ch4_depth_final:co2ch4_depth_final, $
            wl_telluric:wl_soln_tell, $
            wl_telluric_select:wl_soln_tell_select, $
            wl_grid:wl_grid_over, $
            guess:guess, $
            chi2:chi2, $
            chi2_tot:chi2_tot, $
            chi2_nopen:chi2_nopen,$
            chi2_plain:chi2_plain, $
            pscale:pscale, $
            status:status, $
            first_pix:first_pix, $
            npix_select:npix_select, $
            model_arr:model_final, $
            obs_arr:obs_select, $
            err_arr:err_select, $
            ncalls:ncalls, $
            niter:niter $
           }
    
    mwrfits, penstr, outfil
endif


stop



!p.multi=0



end
@


1.6
log
@This is the version that produced the first set of telluric templates.  They looked good, but gave worse chi2.  Reworking now, possibly to fit only h2o at 7x oversampling...
@
text
@d30 1
a30 1
    clock=tic()
d32 16
a47 2
    last_guess=p
    bigc=299792458.D
a48 13
    model_over=dblarr(npix_model, n_exp)
    ;tell_penalty=dblarr(n_elements(select_tell_index), n_exp)
    tell_penalty_h2o=dblarr(n_elements(select_tell_index), n_exp)
    tell_penalty_co2ch4=dblarr(n_elements(select_tell_index), n_exp)
    ;stellar=dblarr(npix_over, n_exp)
    ;telluric_model=dblarr(n_elements(
    
    ;modify telluric with free parameters
    h2o_over[select_tell_index]=p[0:n_elements(wl_soln_tell_select)-1]
    co2ch4_over[select_tell_index]=p[n_elements(wl_soln_tell_select):2*n_elements(wl_soln_tell_select)-1]
    h2o_depth=p[2*n_elements(wl_soln_tell_select):2*n_elements(wl_soln_tell_select)+n_exp-1]
    co2ch4_depth=p[2*n_elements(wl_soln_tell_select)+n_exp:2*n_elements(wl_soln_tell_select)+2*n_exp-1]
    ;delta_rv=p[2*n_elements(wl_soln_tell_select)+2*n_exp:2*n_elements(wl_soln_tell_select)+3*n_exp-1]
a51 1
    
d59 21
d81 9
a89 2
;Loop through exposures for multiply and convolve
    for exp=0, n_exp-1 do begin
d92 2
a93 12
            ;Shift stellar wl
        wl_template_shifted=temp_wl_over*(1d0 + delta_rv[exp]/bigc)
        stellar=interpol(template_over, wl_template_shifted, wl_grid_over[*, exp])
        
        ;scale optical depth of telluric
        h2o_scaled=h2o_over^h2o_depth[exp]
        co2ch4_scaled=co2ch4_over^co2ch4_depth[exp]
        
                                ;save telluric "template" for roughness penalty
;        tell_penalty[*,exp]=h2o_scaled[select_tell_index]*co2ch4_scaled[select_tell_index]
        tell_penalty_h2o[*,exp]=h2o_scaled[select_tell_index]
        tell_penalty_co2ch4[*,exp]=co2ch4_scaled[select_tell_index]
a94 3
        ;put telluric onto wavelength grid
        h2o=interpol(h2o_scaled, wl_soln_tell, wl_grid_over[*,exp])
        co2ch4=interpol(co2ch4_scaled, wl_soln_tell, wl_grid_over[*,exp])
d96 5
a100 20
        ;telluric_model[*,exp]=interpol(h2o*co2ch4, wl_grid_over[*,exp], wl_grid_select[*,exp])
        

        ;Product of stell, tell and nh3
        product_spectrum=stellar*nh3_spectrum[*,exp]*h2o*co2ch4

        model_over[*,exp]= ircs_convolve(product_spectrum, lsf_arr[*,*,exp], oversamp=oversamp, first_pix=first_pix, npix_select=npix_select)

    endfor

        
                                ;Downsample to IRCS resolution
    model = ircsrv_downsample(model_over, oversamp)
        
        
                                ;final IRCS sampled 2d array of models
                                ;for all exposures (n_exp x npix_select)
    model_final=model*norm_factor
    model_longvec=reform(transpose(model_final), n_elements(model_final))
    obs_longvec=reform(transpose(obs_select), n_elements(obs_select))
d104 27
a130 27
    ;Add roughness penalty
    roughpenalty=1
    if roughpenalty ge 1 then begin
                                ;Take first derivative of p
        xv=wl_soln_tell_select
        ;yv=tell_penalty[*,0]
        yv_h2o=tell_penalty_h2o[*,0]
        yv_co2ch4=tell_penalty_co2ch4[*,0]
        dx=xv[1:*]-xv[0:-2]
        ;dy=yv[1:*]-yv[0:-2]
        dy_h2o=yv_h2o[1:*]-yv_h2o[0:-2]
        dy_co2ch4=yv_co2ch4[1:*]-yv_co2ch4[0:-2]
        ;der=dy/dx
        der_h2o=dy_h2o/dx
        der_co2ch4=dy_co2ch4/dx
        
        ;pscale=1d-5
        
;        rpenalty=pscale*total(der[10*oversamp:*]^2, /double) ;FIX
;        careful with this
        rpenalty_h2o=pscale*total(der_h2o[10*oversamp:*]^2, /double) ;FIX careful with this
        rpenalty_co2ch4=pscale*total(der_co2ch4[10*oversamp:*]^2, /double) ;FIX careful with this
        rpenalty=rpenalty_h2o+rpenalty_co2ch4
        penstopon=0
        if penstopon eq 0 then penstop=[0] else penstop=randomu(seed,1)
        if penstop[0] gt .999 then stop
    endif
d132 31
a162 31
                ;Calculate chi2
    if mode eq 'amoeba' then begin
        chi2_allexp=((model_final-obs_select)/err_select)^2
        chi2_arr=total(chi2_allexp, 2, /double)
        chi2=total(chi2_arr, /double)
        chi2_nopen=chi2
        if roughpenalty ge 1 then chi2=chi2+rpenalty
        print, chi2_nopen, chi2
    endif
    if mode eq 'mpfit' or mode eq 'one_call' then begin
        chi_allexp=(obs_select-model_final)/err_select
        ;chi_arr=reform(transpose(chi_allexp), n_elements(chi_allexp))
        chi_arr=reform(chi_allexp, n_elements(chi_allexp))
        ;chi_arr=total(chi_allexp, 2, /double)
        chi2_nopen=total((chi_arr)^2, /double)
        if roughpenalty eq 1 then begin ; this is kinda wrong, but okay
            pen=rpenalty/n_elements(chi_arr)
            pen=sqrt(pen)
            poschi=where(chi_arr ge 0, poscount)
            negchi=where(chi_arr lt 0, negcount)
            if poscount gt 0 then chi_arr[poschi]=chi_arr[poschi]+pen
            if negcount gt 0 then chi_arr[negchi]=chi_arr[negchi]-pen
            chi2_tot=total(chi_arr^2, /double)
        endif else if roughpenalty eq 2 then begin

            negchi=where(chi_arr lt 0, negcount)
            chi2_tot=chi2_nopen+rpenalty
            chi2perpix=chi2_tot/n_elements(chi_arr)
            chiperpix=sqrt(chi2perpix)
            chi_arr=replicate(chiperpix, n_elements(chi_arr))
            if negcount gt 0 then chi_arr[negchi]=-1d0 * chi_arr[negchi]
a163 2
                
        endif
a164 4
        print, chi2_nopen, total(chi_arr^2, /double)
        ;help, chi_arr
        ;help, p
        ;stop
d166 6
d177 10
a186 10
    res_longvec=reform(transpose((obs_select-model_final)), n_elements(obs_select))
    ;i=1
    ;plot, obs_select[*,i], /xs, yr=[0,1.3]
    ;oplot, model_final[*,i], ps=3, color=200
    ;plot, obs_select[*,i]-model_final[*,i], ps=3, /xs
    ;plot, obs_longvec, /xs, yr=[0,1.3]
    ;oplot, model_longvec, ps=6, color=200
    ;plot, res_longvec, /xs, ps=6
    ;oplot, p, ps=3, color=200
    ;wait, 0.01
d188 16
a203 16
    randomon=1
    if randomon eq 1 then begin 
        
        randomplot=randomu(seed, 1) 
    endif else randomplot=[0]
    if randomplot[0] gt 0.99 then begin
        
        !p.multi=[0,3,n_exp]
        for i=0, n_exp-1 do begin
            plot, obs_select[*,i], /xs, yr=[0,1.3]
            oplot, model_final[*,i], ps=3, color=200
            plot, obs_select[*,i]-model_final[*,i], ps=3, /xs, yr=[-0.1,0.1]
            plot, tell_penalty_h2o[*,i], /xs, yr=[0,1.3]
            oplot, tell_penalty_co2ch4[*,i], color=200
        endfor
    endif
d206 11
a216 11
    ;randomstop=randomu(seed, 1)
    randomstop=[0]
    if randomstop[0] gt 0.9 then begin
        for i=0, n_exp-1 do begin
            plot, obs_select[*,i], /xs, yr=[0,1.3]
            oplot, model_final[*,i], ps=3, color=200
            plot, obs_select[*,i]-model_final[*,i], ps=3, /xs
            print, "Obs: ", i, " Chi2: ", total((chi_allexp[*,i]^2), /double)
            stop
        endfor
    endif
d219 4
a222 4
    if mode eq 'amoeba' then return, chi2 
    if mode eq 'mpfit' then return, chi_arr
    if mode eq 'one_call' then begin
        ocstr={model_final:model_final, chi2_nopen:chi2_nopen, chi2_tot:chi2_tot}
d224 2
a225 2
        return, ocstr
    endif
d255 1
a255 1
  modemode, $
d277 1
a277 1
modemode=mode
d349 1
a349 1

d383 1
a383 1
;Read in calibration results
d390 1
a390 1

d397 1
a397 1
;Assume lin_switch is on
d400 1
a400 1
;;;Parameters from earlier calibration
d406 1
a406 3
;;;

;Other parameters and constants
d417 1
a417 1
;Read in LAB SPECTRUM
d427 1
a427 1
;;;Contstruct wl array and oversampled wl array from coeffs
d434 1
a434 1
;Redefine those vectors to reflect only the specified range
d440 2
d444 4
a447 3
;Read in Template
templatefile='/home/stgilhool/RV_projects/IRCS_rv/data/smooth_penalty_test/test16/penaltytest.fits'
temp_ext=30
d452 2
a453 2
if oversamp ne 3 then begin
    temp_oversamp=3L
d457 1
a457 1

d464 1
d467 1
a468 1
;READ IN TELLURIC
d480 2
d483 1
d485 1
a486 1

a487 1
varray=[0,1,2,3,4,6,10,11,12,13]
a489 2

;Define some arrays
d507 1
a509 4
;Now fit each observation

;for visit=0, n_ABobj-1 do begin

d511 1
d514 7
a520 7

;Make observation array
    obs[*, index]=ABspec_arr[visit, *]
;get error for this observation
    err[*, index]=ABerr_arr[visit, *]
;Mask entries
;Cut off pixels on either end of full 1024 pixel spectrum
d523 1
a523 1
    bigerr=1d10                 ;error value for masked pixels
d528 8
a535 7



;READ IN PARAMETERS FROM 2-basis 2-run FITS
;    rfile='/home/stgilhool/RV_projects/IRCS_rv/data/rvshift1_results/GJ273_18Jan2011_AB_0_127_run2sign.fits'
    rfile='/home/stgilhool/RV_projects/IRCS_rv/data/rvshift1_results/GJ273_18Jan2011_AB_0_127_smooth30_r2.fits'

d538 1
a538 1

d547 1
a547 1

d549 5
a553 5


;;;BEGIN MODELING

;Perturb wl soln
d556 1
a556 1

d559 4
a562 4


;NH3 Lab Spectrum: Interpolate onto the oversampled trial grid
;adjust optical depth first
d566 2
a567 5



;Make LSF

d569 3
a571 3


;Correct small normalization errors by multiplying smooth function
d577 1
a577 1
                                ;X vector of same dimensions as ircs-resolution spectrum
d580 1
a580 1
                                ;Create and populate vector with x-coord of node pts
d588 1
a588 1
                                ;Interpolate between nodes with a spline
d592 1
a592 1

d595 4
a598 12
                                ;Truncate observations and errors to model length
                                ;Indices that we are using
select_x = lindgen(npix)
select_index = select_x[first_pix:first_pix+npix_select-1]
select_xx= lindgen(npix_over)
select_index_over = select_xx[first_pix*oversamp:(first_pix*oversamp)+npix_model-1]

temp_display=template_over[select_index_over]
;first_template=rebin(template_over_select, npix_over, n_exp)



d601 1
d605 1
a605 1
;lsf_arr=rebin(lsf, npix_lsf, npix_model, n_exp, n_trials)
a623 1

d627 36
a662 1
guess_orig=[h2o_guess, co2ch4_guess, h2o_depth, co2ch4_depth]; , delta_rv] ;backup
d665 5
a669 3
guess[0:n_elements(wl_soln_tell_select)*2-1]=(1d0+randomn(seed, n_elements(guess_orig)-2*n_exp)*0.001d0)*guess_orig[0:n_elements(wl_soln_tell_select)*2 -1]
toohigh=where(guess gt 1, highcount)
if highcount gt 0 then guess[toohigh]=1d0
a670 1
;guess[150:180]=replicate(0.6d0, 31)+randomn(seed, 31)*0.01
d683 1
a683 1
maxiter=0L
d685 3
a687 3

        ;scalelist=[5d-5, 2.5d-5, 1d-5, 7.5d-6, 5d-6]  
        ;pscale=scalelist[scaleiter]
d689 6
a694 6
	;pscale=(scaleiter)*1d-4+(1d-3 - 1d-4/(maxiter/2.)) 
	;pscale=1d-1^(scaleiter+1)
	pscale=1d-1^(scaleiter+3)
	;pscale=0d0
    if modemode eq 'mpfit' then begin

d696 1
a696 1
                             limits:[0.0001D,1D0]}, n_elements(guess))
d700 2
a701 2
        ;parinfo[2*n_elements(wl_soln_tell_select)+2*n_exp:2*n_elements(wl_soln_tell_select)+3*n_exp-1].limits=[-2000D, 2000D]

d709 1
a709 1

d716 2
a717 2

        modemode='one_call'
d723 10
a732 1
        modemode='mpfit'
d735 1
a735 1
    if modemode eq 'amoeba' then begin
d748 1
a748 1

d751 1
a751 1

d758 2
a759 2

        modemode='one_call'
d762 1
a762 1
        modemode='amoeba'
d780 2
a788 1
            chi2_nopen:chi2_nopen,$
d793 1
a793 1
if scaleiter eq 0 then stop
d795 1
a795 1
    outfil='/home/stgilhool/RV_projects/IRCS_rv/data/telluric_test/test5/tellurictest.fits'
d807 1
a807 1
    modemode='one_call'
d817 10
a826 1

d842 2
a850 1
            chi2_nopen:chi2_nopen,$
d858 1
a858 1
    
d860 2
a861 2
        
        
@


1.5
log
@This version oversamples the observation and the errors (the errors are like err[0],err[0],err[0],err[1],err[1],err[1]...)
@
text
@a10 2
  obs_select_over, $
  err_select_over, $
d14 1
a14 1
  stellar, $
a22 1
  norm_factor_over, $
d47 1
a47 1
    delta_rv=p[2*n_elements(wl_soln_tell_select)+2*n_exp:2*n_elements(wl_soln_tell_select)+3*n_exp-1]
d93 1
a93 1
;    model = ircsrv_downsample(model_over, oversamp)
d98 3
a100 4
;    model_final=model*norm_factor
    model_final=model_over*norm_factor_over
;    model_longvec=reform(transpose(model_final), n_elements(model_final))
;    obs_longvec=reform(transpose(obs_select), n_elements(obs_select))
d134 1
a134 1
        chi2_allexp=((model_final-obs_select_over)/err_select_over)^2
d142 1
a142 5
        chi_allexp=(obs_select_over-model_final)/err_select_over
;         help, chi_allexp
;         help, obs_select_over
;         help, model_final
;         help, err_select_over
d177 1
a177 1
;    res_longvec=reform(transpose((obs_select_over-model_final)), n_elements(obs_select_over))
d197 1
a197 1
            plot, obs_select_over[*,i], /xs, yr=[0,1.3]
d199 1
a199 1
            plot, obs_select_over[*,i]-model_final[*,i], ps=3, /xs, yr=[-0.1,0.1]
d210 1
a210 1
            plot, obs_select_over[*,i], /xs, yr=[0,1.3]
d212 1
a212 1
            plot, obs_select_over[*,i]-model_final[*,i], ps=3, /xs
a242 2
  obs_select_over, $
  err_select_over, $
d246 1
a246 1
  stellar, $
a254 1
  norm_factor_over, $
a499 2
wl_grid_over_select=dblarr(npix_model, n_exp)
wl_grid_down_select=dblarr(npix_select, n_exp)
a501 1
norm_factor_over=dblarr(npix_model, n_exp)
a558 2
    wl_grid_down_select[*, index]=wl_grid_down[first_pix:first_pix+npix_select-1, index]
    wl_grid_over_select[*, index]=wl_grid_over[first_pix*oversamp:(first_pix+npix_select)*oversamp-1 ,index]
a591 1
        norm_factor_over[*,index]=interpol(norm_factor[*,index], x[0:npix_select-1], xx[0:npix_model-1])
a613 18

obs_select_over=interpol(obs_select, wl_grid_down_select, wl_grid_over_select)
err_select_over=dblarr(npix_model, n_exp)
for exp=0, n_exp-1 do begin
    err_select_over[*,exp]=reform(rebin(reform(err_select[*,exp], 1, npix_select), oversamp, npix_select), npix_model)
endfor

; help, obs_select
; help, obs_select_over
; help, err_select
; help, err_select_over
; help, wl_grid_down
; help, wl_grid_down_select
; help, wl_grid_over
; help, wl_grid_over_select
; stop


d637 1
a637 1
guess_orig=[h2o_guess, co2ch4_guess, h2o_depth, co2ch4_depth, delta_rv] ;backup
d641 3
d657 1
a657 1
maxiter=3L
d670 1
a670 1
                             limits:[0.D,1.001D0]}, n_elements(guess))
d674 1
a674 1
        parinfo[2*n_elements(wl_soln_tell_select)+2*n_exp:2*n_elements(wl_soln_tell_select)+3*n_exp-1].limits=[-2000D, 2000D]
d689 1
a689 1
        delta_rv_final=r[2*n_elements(wl_soln_tell_select)+2*n_exp:2*n_elements(wl_soln_tell_select)+3*n_exp-1]
d722 1
a722 1
        delta_rv_final=r[2*n_elements(wl_soln_tell_select)+2*n_exp:2*n_elements(wl_soln_tell_select)+3*n_exp-1]
d734 1
a734 1
            delta_rv_final:delta_rv_final, $
d750 2
a751 2
            obs_arr:obs_select_over, $
            err_arr:err_select_over, $
d759 1
a759 1
    outfil='/home/stgilhool/RV_projects/IRCS_rv/data/telluric_test/test4/tellurictest.fits'
d785 2
d802 2
a803 2
            obs_arr:obs_select_over, $
            err_arr:err_select_over, $
@


1.4
log
@Version with separate smoothness penalties

Next: oversampling the observation
@
text
@d11 2
d25 1
d96 1
a96 1
    model = ircsrv_downsample(model_over, oversamp)
d101 4
a104 3
    model_final=model*norm_factor
    model_longvec=reform(transpose(model_final), n_elements(model_final))
    obs_longvec=reform(transpose(obs_select), n_elements(obs_select))
d138 1
a138 1
        chi2_allexp=((model_final-obs_select)/err_select)^2
d146 5
a150 1
        chi_allexp=(obs_select-model_final)/err_select
d185 1
a185 1
    res_longvec=reform(transpose((obs_select-model_final)), n_elements(obs_select))
d205 1
a205 1
            plot, obs_select[*,i], /xs, yr=[0,1.3]
d207 1
a207 1
            plot, obs_select[*,i]-model_final[*,i], ps=3, /xs, yr=[-0.1,0.1]
d218 1
a218 1
            plot, obs_select[*,i], /xs, yr=[0,1.3]
d220 1
a220 1
            plot, obs_select[*,i]-model_final[*,i], ps=3, /xs
d251 2
d265 1
d511 2
d515 1
d573 2
d608 1
d631 18
d782 2
a783 2
            obs_arr:obs_select, $
            err_arr:err_select, $
d832 2
a833 2
            obs_arr:obs_select, $
            err_arr:err_select, $
@


1.3
log
@"Working" version, but haven't got a good telluric yet

Next: Two changes
1) Calculate roughness penalty for h2o and co2ch4 separately.
2) Try oversampling the observation and error
@
text
@d36 3
a38 1
    tell_penalty=dblarr(n_elements(select_tell_index), n_exp)
d72 4
a75 2
        ;save telluric "template" for roughness penalty
        tell_penalty[*,exp]=h2o_scaled[select_tell_index]*co2ch4_scaled[select_tell_index]
d109 3
a111 1
        yv=tell_penalty[*,0]
d113 6
a118 2
        dy=yv[1:*]-yv[0:-2]
        der=dy/dx
d122 5
a126 1
        rpenalty=pscale*total(der[10*oversamp:*]^2, /double) ;FIX careful with this
d200 2
a201 1
            plot, tell_penalty[*,i], /xs, yr=[0,1.3]
d662 1
a662 1
	pscale=1d-1^(scaleiter+1)
d667 1
a667 1
                             limits:[0.D,1.1D0]}, n_elements(guess))
d756 1
a756 1
    outfil='/home/stgilhool/RV_projects/IRCS_rv/data/telluric_test/test3/tellurictest.fits'
@


1.2
log
@First working telluric fit version.
Puts telluric spectra onto a telluric grid, and the modeling function then interpolates them onto the particular wavelength solution.  Optical depths are also free parameters.

Next: adding stellar rv shift as a free parameter, because it looks like the chi2's are poor.
@
text
@d6 1
d12 2
d33 1
d37 1
d45 4
a48 3
   
                                ;Stellar Template * ammonia
    stell_nh3_spectrum=nh3_spectrum * stellar
d60 5
d79 3
a81 1
        product_spectrum=stell_nh3_spectrum[*,exp]*h2o*co2ch4
d223 1
d229 2
d490 1
a490 1
stellar=dblarr(npix_over, n_exp)
a550 3
;Shift stellar wl
    wl_template_shifted[*, index]=temp_wl_over*(1d0 + delta_rv[index]/bigc)
    stellar[*,index]=interpol(template_over, wl_template_shifted[*,index], wl_grid_over[*, index])
d622 1
a622 2

guess_orig=[h2o_guess, co2ch4_guess, h2o_depth, co2ch4_depth] ;backup
d647 1
a647 1
	pscale=1d-1^(scaleiter+3)
d656 1
d671 1
d704 1
d715 2
d741 1
a741 1
    outfil='/home/stgilhool/RV_projects/IRCS_rv/data/telluric_test/test1/tellurictest.fits'
@


1.1
log
@Initial revision
@
text
@a7 1
  temp_display, $
a9 2
  temp_wl_over, $
  wl_template_shifted, $
d11 7
a17 1
  tell_nh3_spectrum, $
a20 1
  template_over, $
a30 6
    ;Graph Template
    ;plot, temp_display, /xs, yr=[0.2,1.3]
;    wait,0.1

    npix_over=n_elements(template_over)

d32 2
d35 16
a50 1
    template_long=template_over
d52 9
a60 1
    template_long[first_pix*oversamp:(first_pix+npix_select)*oversamp-1]=p
d62 3
a64 3
    ;Spline
    smoothspline=0
    if smoothspline eq 1 then begin
d66 3
a68 3
        template_spline=cspline(temp_wl_over, template_long, temp_wl_over)
        template_arr=rebin(template_spline, npix_over, n_exp)
        stellar_trial=interpol(template_arr, wl_template_shifted, wl_grid_over, /spline)
d70 1
a70 12
    endif else template_arr=rebin(template_long, npix_over, n_exp)

                                ;Stellar Template: RV shift the stellar template
    stellar_trial=interpol(template_arr, wl_template_shifted, wl_grid_over)
    
                                ;Now convolve to make full model
    product_spectrum=tell_nh3_spectrum * stellar_trial
    
        
            
;            product=product_spectrum[*,index]
    for exp=0, n_exp-1 do begin
a71 3
        ;convclockt=ic()
        model_over[*,exp]= ircs_convolve(product_spectrum[*,exp], lsf_arr[*,*,exp], oversamp=oversamp, first_pix=first_pix, npix_select=npix_select)
        ;toc, convclock
d91 2
a92 2
        xv=temp_wl_over[first_pix*oversamp:(first_pix+npix_select)*oversamp-1]
        yv=template_long[first_pix*oversamp:(first_pix+npix_select)*oversamp-1]
d145 5
a149 1
    
d161 1
a161 1
    randomon=0
d166 1
a166 1
    if randomplot[0] gt 0.995 then begin
d173 1
a173 2
            plot, guess, /xs, yr=[0,1.3]
            oplot, template_arr[first_pix*oversamp:(first_pix+npix_select)*oversamp-1, i], color=200, ps=3
d190 1
d206 1
a211 1
  temp_display, $
a213 2
  temp_wl_over, $
  wl_template_shifted, $
d215 7
a221 1
  tell_nh3_spectrum, $
a224 1
  template_over, $
d414 11
a424 2
templatefile=templatepath+object+'_template.dat'
readcol, templatefile, temp_wl, temp_spec, format='D,D'
d426 4
d431 1
a431 15
;oversample the template and template_wl
if n_elements(temp_wl) eq npix then begin
    temp_wl_over=interpol(temp_wl, x, xx)
    template_over=interpol(temp_spec, temp_wl, temp_wl_over)
endif else if oversamp eq 7 then begin
    temp_wl_over=temp_wl
    template_over=temp_spec
    template_over_select=template_over[first_pix*oversamp:(first_pix+npix_select)*oversamp-1]
endif else if oversamp ne 7 then begin
    if n_elements(temp_wl) ne 7*npix then message, 'you are wrong about template npix'
    xx_old=(dindgen(npix*oversamp_old)-(oversamp_old/2))/oversamp_old
    temp_wl_over=interpol(temp_wl, xx_old, xx)
    template_over=interpol(temp_spec, temp_wl, temp_wl_over)
    template_over_select=template_over[first_pix*oversamp:(first_pix+npix_select)*oversamp-1]
endif
d459 3
a461 1
tell_nh3_spectrum=dblarr(npix_over, n_exp)
d472 3
d501 2
a502 1
    rfile='/home/stgilhool/RV_projects/IRCS_rv/data/rvshift1_results/GJ273_18Jan2011_AB_0_127_run2sign.fits'
d509 2
a510 2
    h2o_depth=re[f.h2o_depth_index]
    co2ch4_depth=re[f.co2ch4_depth_index]
d532 1
a532 10
    ammonia=interpol(int_lab_depth, wl_lab, wl_grid_over[*, index])




;Telluric: Adjust optical depths and construct telluric spectrum
    h2o_scaled=h2o^h2o_depth
    co2ch4_scaled=co2ch4^co2ch4_depth
    telluric_long=h2o_scaled*co2ch4_scaled
;put telluric spectrum onto grid
a533 1
    telluric=interpol(telluric_long, wl_telluric, wl_grid_over[*, index])
d535 3
a537 3

;Product of the three
    tell_nh3_spectrum[*,index] = ammonia * telluric
a543 3
;Shift stellar wl
    wl_template_shifted[*, index]=temp_wl_over*(1d0 + delta_rv[index]/bigc)

a582 5
;NOW DO THE BILLIONS OF TRIALS

n_trials=1e2
;maxiter=1e9 - 1

a583 6
                                ;Make 3D arrays out of some of the
                                ;arrays
; wl_template_shifted_arr=rebin(wl_template_shifted, npix_over, n_exp, n_trials)
; wl_grid_over_arr=rebin(wl_grid_over, npix_over, n_exp, n_trials)
; tell_nh3_spectrum_arr=rebin(tell_nh3_spectrum, npix_over, n_exp, n_trials)
; norm_factor_arr=rebin(norm_factor, npix_select, n_exp, n_trials)    
a588 1
;stop
a590 10
guess=template_over_select
tempnorm=max(template_over_select[20:*]) ;careful here!
guess=guess/tempnorm
toohigh=where(guess gt 1, highcount)
toolow=where(guess lt 0, lowcount)
if highcount gt 0 then guess[toohigh]=1d0
if lowcount gt 0 then guess[toolow]=0d0
ftol=1d-10
norm_factor=norm_factor*tempnorm

d592 3
d596 2
a597 4
;Shift template values by small random amts across template
guess_orig=guess ;backup
guess=(1d0+randomn(seed, n_elements(guess))*0.005d0)*guess
;guess[150:180]=replicate(0.6d0, 31)+randomn(seed, 31)*0.01
d599 2
a600 2
maxiter=29L
for scaleiter=0, maxiter do begin
d602 2
a603 17
;scalelist=[5d-5, 2.5d-5, 1d-5, 7.5d-6, 5d-6]  
;pscale=scalelist[scaleiter]
pscale=(scaleiter+1)*1d-6
;pscale=(scaleiter)*1d-4+(1d-3 - 1d-4/(maxiter/2.)) 
;pscale=1d-1^(scaleiter+1)
;pscale=1d-1^(scaleiter+5)
;pscale=0d0
if modemode eq 'mpfit' then begin

    parinfo = replicate({fixed:0, limited:[1,1], $
                       limits:[0.D,1.2D0]}, n_elements(guess))
    
    parinfo[0:10*oversamp].fixed=1

    r=mpfit('templatefit',guess, bestnorm=chi2, ftol=ftol, $
            parinfo=parinfo, status=status, nfev=ncalls, niter=niter, /quiet)
    print, status
a604 2
    final_template=template_over
    final_template[first_pix*oversamp:(first_pix+npix_select)*oversamp-1]=r
d606 2
a607 8
    modemode='one_call'
    oc=templatefit(r)
    
    model_final=oc.model_final
    chi2_nopen=oc.chi2_nopen
    chi2_tot=oc.chi2_tot
    modemode='mpfit'
endif
a608 20
if modemode eq 'amoeba' then begin
    window, 1, xsize=1200, ysize=650
    scale=replicate(1d-2, n_elements(template_over_select))

    r=amoeba3(ftol, scale=scale, p0=guess,function_name='templatefit', $
              function_value=fval, ncalls=ncalls, nmax=150000L)
    niter=ncalls
    status=-888
    if n_elements(r) eq 1 then begin
        r=last_guess
        status=-999
    endif
    chi2=fval[0]
    final_template=template_over
    final_template[first_pix*oversamp:(first_pix+npix_select)*oversamp-1]=r
    modemode='one_call'
    oc=templatefit(r)
    chi2_tot=oc.chi2_tot
    modemode='amoeba'
endif
d610 5
a615 17
penstr={template:r, $
        guess:guess, $
        chi2:chi2, $
        chi2_tot:chi2_tot, $
        template_spec:final_template, $
        template_wl:temp_wl_over, $
        pscale:pscale, $
        status:status, $
        first_pix:first_pix, $
        npix_select:npix_select, $
        model_arr:model_final, $
        obs_arr:obs_select, $
        err_arr:err_select, $
        chi2_nopen:chi2_nopen,$
        ncalls:ncalls, $
        niter:niter $
        }
d617 9
a625 1
;if scaleiter eq 0 then stop
d627 2
a628 1
outfil='/home/stgilhool/RV_projects/IRCS_rv/data/smooth_penalty_test/test16/penaltytest.fits'
d630 51
a680 1
mwrfits, penstr, outfil
d682 2
d685 5
d691 39
d737 1
a737 1
    oc=templatefit(guess_orig)
d746 11
a756 1
    penstr={template:guess_orig, $
a759 2
            template_spec:final_template, $
            template_wl:temp_wl_over, $
a771 2
;if scaleiter eq 0 then stop
    
a783 10
;bestfile= '/home/stgilhool/RV_projects/IRCS_rv/data/GJ273/templatefit.fits'
;outstr={template:final_template, $
;        chi2:chi2 $
;        }

;mwrfits, outstr, bestfile

;stop


@
