function cb_hermite, n, x_in, sigma

;n is order, x is the (x-x0) term in the Gaussian, and sigma is the
;sigma of the Gaussian, in the same units as x_in

n=n*1d0

x=x_in/sigma

h=0d

m=n/2l

for i=0l, m do h=h+(-1d0)^(i*1d0)*(2d0*x)^(n-2d0*i)/(factorial(m)*factorial(n-2*i))

output=(1./sqrt(sigma))*(2d0^n*factorial(n)*Sqrt(!pi))^(-0.5d0)*factorial(n)*h*exp(-x_in^2d0/(2d0*sigma^2d0))



return, output

end



function continuum_fit, x_vec, int, low_rej=low_rej, high_rej=high_rej, PIX_MASK=mask, verbose=verbose

;Initialize arrays and loop variables
npix=n_elements(x_vec)
if n_elements(mask) eq 0 then mask=replicate(0,npix)
if n_elements(low_rej) eq 0 then low_rej=0.5
if n_elements(high_rej) eq 0 then high_rej=3.
if n_elements(verbose) eq 0 then verbose=0
n_iter=10
n_reject=0
n_reject_total=0
deg=5

;Apply pixel mask
unmask_index=where(mask eq 0)
x_vec=x_vec[unmask_index]
int=int[unmask_index]

;Copy vectors for iteration
x_vec_iter=x_vec
int_iter=int


;;;;Iteratively fit the spectrum to approximate continuum
for iteration=1,n_iter do begin
    
    ;Fit a robust 5th degree polynomial to data
    fit_coeff=robust_poly_fit(x_vec_iter, int_iter, deg, fit_iter, sig)
   
    ;Define upper and lower rejection bounds
    upper_bound=fit_iter+(high_rej*sig)
    lower_bound=fit_iter-(low_rej*sig)
    
    ;Find the indices where the data are within the bounds
    keep_index=where(int_iter le upper_bound and int_iter ge lower_bound)
    
    ;And keep track of the points that are rejected
    rej_index=where(int_iter gt upper_bound or int_iter lt lower_bound, rej_count)
    if rej_count gt 0 then begin
        n_reject=n_elements(rej_index)
        n_reject_total=n_reject_total+n_reject
    endif else n_reject=0

;     ;Stop iterating if code rejects half of the data or more
;                                 NOTE: This needs to be fixed so as to
;                                 output the last iteration's fit!
;     if n_reject_total ge 0.5*n_elements(x_vec) then begin
;         if verbose ne 0 then print, "Too many rejections. Exiting loop at iteration number: ", iteration
;         break
;         endif

    ;Calculate RMSE
    rmse=sqrt(mean((fit_iter-int_iter)^2))

    ;Display fit if verbose is set
    if verbose ne 0 then begin
                                ;Plot the fit and rejected points
        window, 1, xsize=1300, ysize=650
        plot, x_vec, int, /xs
        oplot, x_vec_iter, fit_iter, color=200
        if rej_count gt 0 then oplot, x_vec_iter[rej_index], int_iter[rej_index], ps=7
        
                                ;Print the results
        print, "Iteration number: ", iteration
        print, "Coefficients: ", fit_coeff
        print, "Sigma: ", sig
        print, "Number of rejected points (current iteration): ", n_reject
        print, "Number of rejected points (in total): ", n_reject_total
        print, "RMSE: ", rmse
        print, ""
        ;stop
    endif

    ;Change x_vec_iter and int_iter according to rejection
    x_vec_iter=x_vec_iter[keep_index]
    int_iter=int_iter[keep_index]

endfor

;create array to return
fit=dblarr(n_elements(int))
order=dblarr(n_elements(int))
for i=0,deg do begin
    order=fit_coeff[i]*(x_vec^i)
    fit=fit+order
endfor

;plot, x_vec, int, /xs
;oplot, x_vec, fit, color=200
;stop

return, fit

end


function amoebafunction, p

common amoeba_info, wl_lab, int_lab, int_obs, nparam_wl, nparam_gh, nparam_other, lin_switch, trial_lsf


;;;Parameters from amoeba
nparam=n_elements(p)

wl_coeff=p[0:nparam_wl-1]

gh_coeff=p[nparam_wl:nparam_wl+nparam_gh-1]
sigma=gh_coeff[0]

if lin_switch eq 1 then begin
    gh_lin_coeff=p[nparam_wl+nparam_gh:nparam_wl+(2*nparam_gh)-1]
    other=p[nparam_wl+(2*nparam_gh):nparam-1]
endif else other=p[nparam_wl+nparam_gh:nparam-1]
tau_scale=other[0]


;Other parameters and constants
sigma_round=round(sigma)+1 ;for helping to make npix_lsf odd
npix_lsf=(10*sigma_round)+1
c=299792458.D
npix=1024L
oversamp=7L



;Adjust the optical depth of the lab spectrum (I think this is okay to
;do for the high-resolution spectrum even though the wl scale isn't linear)
int_lab_depth=int_lab^tau_scale


;;;Contstruct wl array and oversampled wl array from coeffs
x=dindgen(npix)
xx=dindgen(npix*oversamp)

trial_soln=poly(x, wl_coeff)
samp_index=(indgen(npix)*oversamp)+(oversamp/2)
trial_soln_over=interpol(trial_soln, samp_index, xx)


;Interpolate the lab spectrum onto the oversampled trial grid
int_lab_over=interpol(int_lab_depth, wl_lab, trial_soln_over)


;Make lsf in the case that it's the same LSF accross the detector
if lin_switch eq 0 then begin
    x_lsf=dindgen(npix_lsf)-(npix_lsf/2)
    trial_lsf=cb_hermite(0, x_lsf, sigma) ;0th order is gaussian
    nbasis=nparam_gh-1          ;go up to 4th order
    ostart=1l                   ;start with order 1
    for j=0l, nbasis-1 do trial_lsf=trial_lsf+(cb_hermite(j+ostart, x_lsf, sigma)*gh_coeff[j+1])
;normalize
    trial_lsf=trial_lsf/total(trial_lsf)
    neg_point=min(trial_lsf)
    if neg_point lt 0 then begin
        trial_lsf=trial_lsf - neg_point
        trial_lsf=trial_lsf/total(trial_lsf)
    endif

endif else begin ;case for wl-dependent change in lsf shape
    npix_model=n_elements(int_lab_over)
    x_lsf=dindgen(npix_lsf)-(npix_lsf/2)
    trial_lsf=dblarr(npix_lsf, npix_model)
    ;Define some data cubes
    lsf_cube=dblarr(npix_lsf, npix_model, nparam_gh)
    const_coeff_cube=dblarr(npix_lsf, npix_model, nparam_gh)
    lin_coeff_cube=dblarr(npix_lsf, npix_model, nparam_gh)
    pix_num_cube=rebin(reform(dindgen(npix_model), 1, npix_model), npix_lsf, npix_model, nparam_gh)
    ;Populate the data cubes
                                ;Do 0th order (this part can be in the
                                ;loop unless we start adding
                                ;additional bases at higher orders
                                ;than 1)
    ;lsf_cube[*,*,0]=rebin(cb_hermite(0, x_lsf, sigma), npix_lsf, npix_model)
    ;const_coeff_cube[*,*,0]=replicate(1d0, npix_lsf, npix_model) 
    ;lin_coeff_cube[*,*,0]=gh_lin_coeff[0]*pix_num_cube[*,*,0]
    ostart=0
    for basis=ostart, nparam_gh-1 do begin
        lsf_cube[*,*,basis]=rebin(cb_hermite(basis+ostart, x_lsf, sigma), npix_lsf, npix_model)
        if basis eq 0 then const_coeff_cube[*,*,0]=replicate(1d0, npix_lsf, npix_model) $
          else const_coeff_cube[*,*,basis]=replicate(gh_coeff[basis], npix_lsf, npix_model)
        lin_coeff_cube[*,*,basis]=gh_lin_coeff[basis]*pix_num_cube[*,*,basis]
    endfor
    ;Combine the cubes
    coeff_cube=const_coeff_cube+lin_coeff_cube
    lsf_cube_full=lsf_cube*coeff_cube
    ;Make the final lsf array (2D)
    trial_lsf=total(lsf_cube_full, 3, /double)
    ;Shift lsf if it has negative entries
    for pixel=0, npix_model-1 do begin
        neg_point=min(trial_lsf[*,pixel])
        if neg_point lt 0 then trial_lsf[*,pixel]=trial_lsf[*,pixel] - neg_point
        trial_lsf[*,pixel]=trial_lsf[*,pixel]/total(trial_lsf[*,pixel])
    endfor
       ; stop
    ;Old, hopefully less efficient way of making the lsf matrix
    ;for pixel=0,npix_model-1 do begin
    ;    trial_lsf[*,pixel]=cb_hermite(0, x_lsf, sigma)*(1d0+(gh_lin_coeff[0]*pixel))
    ;    nbasis=nparam_gh-1      ;go up to 4th order
    ;    ostart=1l               ;start with order 1
    ;    for j=0l, nbasis-1 do trial_lsf[*,pixel]=trial_lsf[*,pixel]+ $
    ;      (cb_hermite(j+ostart, x_lsf, sigma)*(gh_coeff[j+ostart]+(gh_lin_coeff[j+ostart]*pixel)))
    ;    trial_lsf[*,pixel]=trial_lsf[*,pixel]/total(trial_lsf[*,pixel])
    ;neg_point=min(trial_lsf[*,pixel])
    ;if neg_point lt 0 then begin
    ;    trial_lsf[*,pixel]=trial_lsf[*,pixel] - neg_point
    ;    trial_lsf[*,pixel]=trial_lsf[*,pixel]/total(trial_lsf[*,pixel])
    ;endif
    ;stop
    ;endfor
endelse
;stop
;!p.multi=0

;for test=0, npix_model-1 do begin
;    num=string(test)
;    plot,trial_lsf[*,test], title=num
;    wait,0.01
;endfor
;stop

;Convolve model with lsf
if lin_switch eq 0 then begin
    int_lab_conv=convol(int_lab_over, trial_lsf) ;, /norm) 
endif else begin
    int_lab_conv=dblarr(npix_model)
    ;int_lab_conv[0:npix_lsf/2-1]=1d0
    ;int_lab_conv[npix_model-1-(npix_lsf/2):npix_model-1]=1d0
                                ;Make matrix of pieces of the spectrum
                                ;that will be convolved with lsf at
                                ;each pixel
    ;int_lab_conv_mtx=dblarr(npix_model, npix_lsf)
    
    ;for index=0,npix_model-1-npix_lsf do begin
    ;    int_lab_conv_mtx[index, *]=int_lab_over[index:index+npix_lsf-1]
    ;endfor
    int_lab_conv_mtx=dblarr(npix_lsf, npix_model)
    
    for index=0,npix_model-1 do begin
        if (index lt npix_lsf/2 or index gt (npix_model-1-(npix_lsf/2))) then $
            int_lab_conv_mtx[*,index]=replicate(1d0, npix_lsf) $
          else int_lab_conv_mtx[*,index]=int_lab_over[index-(npix_lsf/2):index+(npix_lsf/2)]
    endfor
    int_lab_conv_temp=int_lab_conv_mtx*trial_lsf
    int_lab_conv=total(int_lab_conv_temp, 1, /double)
;help, int_lab_conv
;stop
endelse
        

;    for x_var=0,npix_model-1 do begin
;        x_coord_lsf=x_lsf+x_var ;shift the position of the lsf on the spectrum
;        lsf_trim_index=where(x_coord_lsf ge 0 and x_coord_lsf lt npix_model)
;        x_lsf_mod=x_coord_lsf[lsf_trim_index]
;        trial_lsf_mod=trial_lsf[lsf_trim_index,x_var]
;        int_overlap=int_lab_over[x_coord_lsf]
;        int_lab_conv[x_var]=total(int_overlap*trial_lsf_mod)
;stop
;stop

;Down-sample the model to IRCS resolution
npix_tophat=oversamp
tophat=replicate(1d0/npix_tophat,npix_tophat)
int_lab_avg=convol(int_lab_conv, tophat)
int_model=int_lab_avg[samp_index] 


;;;Get chi^2
err=0
chi2=0
chi_scale=1.85d-5  ;scale factor chosen to make chi2 ~ DoF
 for pixel=69, npix-70 do begin  ;cut off 50 pixels on either end
   
     err=((int_obs[pixel]-int_model[pixel])^2)/chi_scale
    
     chi2=chi2+err
    
 endfor


;;;Do animation of fitting spectrum for full spectrum
; !p.multi=0
;Set up some stuff to help display lsf across spectrum
x1=npix/4
x2=npix/2
x3=x1+x2

xx1=x1*oversamp+(oversamp/2)
xx2=x2*oversamp+(oversamp/2)
xx3=x3*oversamp+(oversamp/2)
if lin_switch eq 1 then begin
    lsf1=trial_lsf[*,xx1]
    lsf2=trial_lsf[*,xx2]
    lsf3=trial_lsf[*,xx3]
    
endif else begin
    lsf1=trial_lsf
    lsf2=trial_lsf
    lsf3=trial_lsf
endelse

max_lsf=max(lsf1)>max(lsf2)>max(lsf3)
x1_vec=dindgen(npix_lsf)+x1
x2_vec=dindgen(npix_lsf)+x2
x3_vec=dindgen(npix_lsf)+x3

residuals=int_obs-int_model

plot, int_obs,yr=[0.1,1.1], /xs;xr=[2.31,2.33]
oplot, int_model, color=200 
plot, residuals, yr=[-0.1, 0.1], ps=3, /xs
plot, x1_vec, lsf1, yr=[-0.05*max_lsf,1.1*max_lsf], xr=[0,npix]
oplot, x2_vec, lsf2
oplot, x3_vec, lsf3

;wait, 0.05

print, p
print, chi2
print, "----------"
;stop
;randomstop=randomu(seed)
;if randomstop le 0.01 then stop

return, chi2

end

pro IRCS_cal, wl_guess, wl_scale, gh_guess, gh_scale, gh_lin_guess, gh_lin_scale, other_guess, other_scale, run, lin_switch=lin_switch

if n_elements(lin_switch) eq 0 then lin_switch=1

common amoeba_info, wl_lab, int_lab, int_obs, nparam_wl, nparam_gh, nparam_other, linear_switch, trial_lsf
linear_switch=lin_switch
;start clock
clock=tic()

;read in both spectra
readcol, 'NH3_model.dat', wl_lab, int_lab, format='D,D'
readcol, 'NH3_obs_nonorm.dat', trash, int_obs_nonorm_backwards, format='I,D'


;flip the spectrum to read low to high
int_obs_nonorm=reverse(int_obs_nonorm_backwards)

low_reject=0.53
high_reject=3.0
;Normalize the model spectrum and the observed spectrum
norm=continuum_fit(wl_lab, int_lab, low_rej=low_reject, high_rej=high_reject)
int_lab_copy=int_lab
int_lab=int_lab_copy/norm

wl_proxy=dindgen(n_elements(int_obs_nonorm))
norm_obs=continuum_fit(wl_proxy, int_obs_nonorm, low_rej=low_reject, high_rej=high_reject)
int_obs=int_obs_nonorm/norm_obs

;directly compare them using AMOEBA
;;;;;;;;;;;;;;;;;;;;;;
;;;  Run amoeba   ;;;;
;;;;;;;;;;;;;;;;;;;;;;

;;;Define amoeba inputs
ftol=1e-10
oversamp=7L
;trial_lsf=dblarr(100)

;Numbers of parameters
nparam_wl=n_elements(wl_guess)
nparam_gh=n_elements(gh_guess)
nparam_other=n_elements(other_guess)
if lin_switch eq 0 then begin
    nparam_gh_lin=0 
    nparam_gh_tot=nparam_gh
endif else begin
    nparam_gh_lin=n_elements(gh_lin_guess)
    nparam_gh_tot=nparam_gh+nparam_gh_lin
endelse
nparam_tot=nparam_wl+nparam_gh_tot+nparam_other

;;;Define guess and scale vectors
if lin_switch eq 1 then begin
    guess=[wl_guess, gh_guess, gh_lin_guess, other_guess]    
    scale=[wl_scale, gh_scale, gh_lin_scale, other_scale]
endif else begin
    guess=[wl_guess, gh_guess, other_guess]    
    scale=[wl_scale, gh_scale, other_scale]
endelse



;window,0,xsize=2050, ysize=900
window, 0, xsize=1000, ysize=400
!p.multi=[0,1,3]
;;;Run amoeba
r=amoeba3(ftol, scale=scale, p0=guess,function_name='amoebafunction', $
         function_value=fval, nmax=15000)

!p.multi=0

;stop clock
process_time=toc(clock)

;;;Print final results for a given file
chi2_fund=875.46206d0
chi2=fval[0]
DoF_fund=875d0
DoF=884d0-nparam_tot
F_crit=((chi2_fund-chi2)/(DoF_fund-DoF))/(chi2/DoF)
prob=mpftest(F_crit, DoF_fund-DoF, DoF)

model_id=strtrim(nparam_wl,2)+"_"+strtrim(nparam_gh,2)+"_"+strtrim(nparam_gh_lin,2)+"_"+strtrim(nparam_other,2)
wl_result=dblarr(nparam_wl)
gh_result=dblarr(nparam_gh)
if lin_switch eq 1 then gh_lin_result=dblarr(nparam_gh_lin)
other_result=dblarr(nparam_other)

print, "---------------------------------"
print, "Model ID: ", model_id
print, "---------------------------------"
print, "Wavelength solution coeffiecients:"
for i=0, nparam_wl-1 do begin
    wl_result[i]=r[i]
    print, r[i]
endfor
print, "---------------------------------"
print, "Gauss-Hermite coefficients:"
for i=nparam_wl, nparam_wl+nparam_gh-1 do begin
    gh_result[i-nparam_wl]=r[i]
    print, r[i]
endfor
print, "---------------------------------"

if lin_switch eq 1 then begin
    print, "Gauss-Hermite linear trend coefficients: "
    for i=nparam_wl+nparam_gh, nparam_wl+(2*nparam_gh)-1 do begin
        gh_lin_result[i-nparam_wl-nparam_gh]=r[i] 
        print, r[i]
        endfor
    print, "---------------------------------"
endif

print, "Other coefficients:"
for i=nparam_tot-nparam_other, nparam_tot-1 do begin
    other_result[i-nparam_tot+nparam_other]=r[i]
    print, r[i]
endfor
print, "---------------------------------"
print, "Chi Squared, n_freeparams, degrees of freedom, F, prob:"
print, chi2
print, nparam_tot
print, DoF
print, F_crit
print, prob
print, "---------------------------------"
print, "Processing took ", process_time, " seconds."




if lin_switch eq 1 then begin
    guess_str={wl:wl_guess, gh0:gh_guess, gh1:gh_lin_guess, other:other_guess}
    scale_str={wl:wl_scale, gh0:gh_scale, gh1:gh_lin_scale, other:other_scale}
    result_str={wl:wl_result, gh0:gh_result, gh1:gh_lin_result, other:other_result, nparam:nparam_tot, chi2:chi2}    
endif else begin
    guess_str={wl:wl_guess, gh0:gh_guess, other:other_guess}
    scale_str={wl:wl_scale, gh0:gh_scale, other:other_scale}
    result_str={wl:wl_result, gh0:gh_result, other:other_result, nparam:nparam_tot, chi2:chi2}    
endelse

str={run_number:run, guesses:guess_str, scales:scale_str, results:result_str}
outfile="model_"+model_id+".fits"

mwrfits, str, outfile




;Add entry to model_info.dat file
;openw, lun, 'model_info.dat', /get_lun, /append
;printf, lun, model_num, chi2, DoF
;close, lun
;free_lun, lun
;print, "Added entry" 

;Display final lsf, with a red, simple gaussian overplotted
;pure_gauss=gaussian_function(r[nparam_wl], width=n_elements(trial_lsf), /normalize)
;plot, trial_lsf, yr=[-0.2, max(trial_lsf > pure_gauss)*1.1]
;oplot, pure_gauss, color=200
;stop
;;;Write to file
;output_file='result_'+result_label+'_epoch.fits'
;if epoch_num eq initial_epoch then mwrfits, mjd, output_file, /create $
;else mwrfits, mjd, output_file
;mwrfits, velocity, output_file
;mwrfits, mjd_epoch, output_file
;mwrfits, avg_rv, output_file
;mwrfits, err_bar, output_file
;mwrfits, chi2_all, output_file
;mwrfits, wl_param0, output_file
;mwrfits, wl_param1, output_file 
end
